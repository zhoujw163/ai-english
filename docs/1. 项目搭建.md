# 项目搭建

采用 基于 pnpm 的 monorepo 架构，项目结构如下：

- apps：前端应用（web、mobile、admin...）
- packages：前后端公共库（ui、utils、config...）
- server：后端应用（微服务server、ai...）

常用的 monorepo 方案有：

- lerna：传统的多包发布管理工具。在版本管理和发布流水线方面有成熟实践。
- turborepo：高性能任务编排器。主打极速构建，通过智能缓存和并行执行大幅提升本地及 CI 速度。配置简单直接。
- nx：完整的 Monorepo 开发平台。除了任务编排，还提供强大的项目图分析、代码生成器、依赖边界约束等高级功能

- pnpm workspaces：轻量高效，通过硬链接节省磁盘空间，依赖管理严格。

中大型项目Monorepo方案核心挑战在于确保性能（构建速度）、可维护性和团队协作在项目膨胀时依然可控。
一般就是 Nx 或者 Turborepo + pnpm 的方案。 

## 初始化项目

### 前端项目

vue + typescript + element-plus + tailwindcss

1. 新建apps目录，用于存放前端项目
2. 进入apps目录，执行 `npm init vue` 命令初始化vue项目
3. 修改 package.json 中的 name 字段，添加前缀 `@en/`，统一命名空间
4. 前端工程处理（ui库的自动按需导入、三方依赖库的api的自动导入）

```ts
// vite.config.ts
import AutoImport from 'unplugin-auto-import/vite';
import Components from 'unplugin-vue-components/vite';
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers';
import ElementPlus from 'unplugin-element-plus/vite';

// https://vite.dev/config/
export default defineConfig({
  server: {
    port: CONFIG.ports.web
  },
  plugins: [
    // ...
    // 自动导入element-plus 和 三方依赖库的api的自动导入
    AutoImport({
      resolvers: [ElementPlusResolver()],
      imports: ['vue', 'vue-router', 'pinia'],
      dts: 'auto-imports.d.ts'
    }),
    Components({
      resolvers: [ElementPlusResolver()],
      dts: 'components.d.ts'
    }),
    // 解决message、notification等组件按需导入的样式缺失问题
    ElementPlus({
      useSource: true
    })
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
});
```

在组件引入 element plus 组件能有 ts 类型提示

```json
// tsconfig.json
"compilerOptions": {
  "types": ["element-plus/global"]
}
```

### 后端项目

1. 执行 `nest new server` 初始化后端项目
2. 修改 package.json 中的 name 字段，添加前缀 `@en/`，统一命名空间
3. 执行 `nest g app ai` 初始化 ai 微服务项目
4. 执行 `nest g lib shared` 初始化后端共享库项目
5. 执行 `nest g res chat --project ai` 初始化 ai 微服务项目中的 chat 资源
6. 执行 `nest g res user --project server` 初始化 server 微服务项目中的 user 资源
7. 执行 `nest g mo prisma --project shared` 初始化后端共享库项目中的 prisma 模块
8. 执行 `nest g s  prisma --project shared` 初始化后端共享库项目中的 prisma 服务

修改 nest-cli.json 

```json
{
  "webpack":true, //移除这一行代码
  "generateOptions": {
    "spec": false
  }
}
```

### 前后端公共依赖

1. 新建 packages/common、packages/config 目录，执行 `pnpm init` 初始化项目
2. 修改 packages/common、packages/config 目录中的 package.json 中的 name 字段，添加前缀 `@en/`，统一命名空间
3. 安装本地模块

```bash
pnpm --filter @en/web add @en/config@workspace:*
pnpm --filter @en/server add @en/config@workspace:*
```

注意点：

由于 nest 打包后使用的是 commonjs 规范，而我们的前端项目使用的是 esm 规范，所以需要增加 type 和 exports 字段

```json
{
  "name": "@en/common",
  "main": "index.js",
  "type": "module", // 表示该模块是 esm 规范
  "exports": { // 指明模块路径，处理 nest 打包后找不到模块的问题
    ".": "./index.ts"
  },
}
```

### 第二阶段配置启动命令

concurrently可以同时启动多个命令

```bash
# 在根目录安装依赖需要 -w 选项
pnpm install concurrently -w
```


pnpm --filter就是指定包名启动命令

```bash
pnpm --filter @en/server start:dev
pnpm --filter @en/ai start:dev
pnpm --filter @en/web start:dev
```

```json
{
	"scripts": {
		"web":"pnpm --filter @en/web dev",
		"server":"pnpm --filter @en/server start:dev",
		"ai":"pnpm --filter @en/server start:dev ai",
		"all":"concurrently \"pnpm run web\" \"pnpm run server\" \"pnpm run ai\""
	},
}
```